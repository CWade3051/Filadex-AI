/**
 * G-code Parser Utility
 * Extracts print information from G-code files for various slicers
 */

export interface GcodeInfo {
  // Basic print info
  filename?: string;
  printName?: string;
  
  // Filament usage
  filamentUsedGrams?: number;
  filamentUsedMeters?: number;
  filamentDiameter?: number;
  filamentType?: string;
  
  // Time estimates
  estimatedTimeMinutes?: number;
  estimatedTimeSeconds?: number;
  
  // Print settings
  layerHeight?: number;
  firstLayerHeight?: number;
  nozzleDiameter?: number;
  bedTemp?: number;
  hotendTemp?: number;
  
  // Slicer info
  slicerName?: string;
  slicerVersion?: string;
  
  // Object/model info
  objectName?: string;
  
  // Thumbnail data (base64)
  thumbnail?: string;
  thumbnailFormat?: string;
}

interface SlicerPattern {
  name: RegExp;
  version: RegExp;
  filamentUsedGrams: RegExp;
  filamentUsedMeters: RegExp;
  estimatedTime: RegExp;
  layerHeight: RegExp;
  bedTemp: RegExp;
  hotendTemp: RegExp;
  filamentType: RegExp;
  objectName: RegExp;
}

// Patterns for different slicers
const SLICER_PATTERNS: Record<string, Partial<SlicerPattern>> = {
  // PrusaSlicer / OrcaSlicer / BambuStudio (similar format)
  prusa: {
    name: /;\s*generated by\s+(PrusaSlicer|OrcaSlicer|BambuStudio)\s+/i,
    version: /;\s*generated by\s+(?:PrusaSlicer|OrcaSlicer|BambuStudio)\s+(\d+\.\d+\.\d+)/i,
    filamentUsedGrams: /;\s*filament\s+used\s*\[g\]\s*=\s*([\d.]+)/i,
    filamentUsedMeters: /;\s*filament\s+used\s*\[mm?\]\s*=\s*([\d.]+)/i,
    estimatedTime: /;\s*estimated\s+printing\s+time\s*(?:\(normal\s+mode\))?\s*=\s*(.+)/i,
    layerHeight: /;\s*layer_height\s*=\s*([\d.]+)/i,
    bedTemp: /;\s*bed_temperature\s*=\s*(\d+)/i,
    hotendTemp: /;\s*temperature\s*=\s*(\d+)/i,
    filamentType: /;\s*filament_type\s*=\s*(.+)/i,
    objectName: /;\s*HEADER_OBJECT_NAME\s*=?\s*(.+)/i,
  },
  // Cura
  cura: {
    name: /;\s*Generated\s+with\s+Cura[_\s]?Engine\s*/i,
    version: /;\s*Cura[_\s]?Engine\s+version\s+([\d.]+)/i,
    filamentUsedGrams: /;\s*Filament\s+weight\s*=\s*([\d.]+)/i,
    filamentUsedMeters: /;\s*Filament\s+used\s*:\s*([\d.]+)m/i,
    estimatedTime: /;\s*TIME\s*:\s*(\d+)/i,
    layerHeight: /;\s*Layer\s+height\s*:\s*([\d.]+)/i,
    bedTemp: /;\s*Build\s+plate\s+temperature\s*:\s*(\d+)/i,
    hotendTemp: /;\s*Printing\s+temperature\s*:\s*(\d+)/i,
    filamentType: /;\s*MATERIAL_TYPE\s*=\s*(.+)/i,
    objectName: /;\s*MESH\s*:\s*(.+)/i,
  },
  // Simplify3D
  simplify3d: {
    name: /;\s*G-Code generated by Simplify3D/i,
    version: /;\s*Simplify3D\s+Version\s+([\d.]+)/i,
    filamentUsedGrams: /;\s*Filament\s+Weight\s*:\s*([\d.]+)\s*g/i,
    filamentUsedMeters: /;\s*Filament\s+Length\s*:\s*([\d.]+)\s*mm/i,
    estimatedTime: /;\s*Build\s+Time\s*:\s*(.+)/i,
    layerHeight: /;\s*Layer\s+height\s*:\s*([\d.]+)/i,
  },
  // SuperSlicer
  superslicer: {
    name: /;\s*generated by\s+SuperSlicer\s+/i,
    version: /;\s*generated by\s+SuperSlicer\s+(\d+\.\d+\.\d+)/i,
    filamentUsedGrams: /;\s*filament\s+used\s*\[g\]\s*=\s*([\d.]+)/i,
    filamentUsedMeters: /;\s*filament\s+used\s*\[mm?\]\s*=\s*([\d.]+)/i,
    estimatedTime: /;\s*estimated\s+printing\s+time\s*=\s*(.+)/i,
  },
};

/**
 * Parse a time string like "1h 23m 45s" or "5432" (seconds) to minutes
 */
function parseTimeToMinutes(timeStr: string): number {
  // If it's just a number, assume seconds
  if (/^\d+$/.test(timeStr.trim())) {
    return Math.round(parseInt(timeStr) / 60);
  }
  
  let totalMinutes = 0;
  
  // Match hours
  const hourMatch = timeStr.match(/(\d+)\s*h/i);
  if (hourMatch) {
    totalMinutes += parseInt(hourMatch[1]) * 60;
  }
  
  // Match minutes
  const minMatch = timeStr.match(/(\d+)\s*m(?:in)?/i);
  if (minMatch) {
    totalMinutes += parseInt(minMatch[1]);
  }
  
  // Match seconds
  const secMatch = timeStr.match(/(\d+)\s*s(?:ec)?/i);
  if (secMatch) {
    totalMinutes += Math.round(parseInt(secMatch[1]) / 60);
  }
  
  // Match days
  const dayMatch = timeStr.match(/(\d+)\s*d/i);
  if (dayMatch) {
    totalMinutes += parseInt(dayMatch[1]) * 24 * 60;
  }
  
  return totalMinutes || 0;
}

/**
 * Extract thumbnail from G-code (usually embedded as base64)
 */
function extractThumbnail(content: string): { data?: string; format?: string } {
  // PrusaSlicer/OrcaSlicer/BambuStudio format
  // ; thumbnail begin WxH length
  const thumbnailStart = content.match(/;\s*thumbnail\s+begin\s+(\d+)x(\d+)\s+(\d+)/i);
  if (thumbnailStart) {
    const endPattern = /;\s*thumbnail\s+end/i;
    const startIdx = content.indexOf(thumbnailStart[0]) + thumbnailStart[0].length;
    const endIdx = content.search(endPattern);
    
    if (endIdx > startIdx) {
      const thumbnailData = content
        .slice(startIdx, endIdx)
        .split('\n')
        .map(line => line.replace(/^;\s*/, '').trim())
        .filter(line => line.length > 0)
        .join('');
      
      // Detect format from header or assume PNG
      const isPng = thumbnailData.startsWith('iVBOR');
      const isJpeg = thumbnailData.startsWith('/9j/');
      
      return {
        data: thumbnailData,
        format: isPng ? 'png' : isJpeg ? 'jpeg' : 'png',
      };
    }
  }
  
  return {};
}

/**
 * Parse G-code content and extract print information
 */
export function parseGcode(content: string, filename?: string): GcodeInfo {
  const result: GcodeInfo = {
    filename,
  };
  
  // Read only the first 10000 characters for header info (performance)
  const headerContent = content.slice(0, 50000);
  
  // Detect slicer
  let detectedSlicer = '';
  for (const [slicerKey, patterns] of Object.entries(SLICER_PATTERNS)) {
    if (patterns.name && patterns.name.test(headerContent)) {
      detectedSlicer = slicerKey;
      
      // Get slicer name and version
      const nameMatch = headerContent.match(patterns.name);
      if (nameMatch) {
        result.slicerName = nameMatch[1] || slicerKey;
      }
      
      if (patterns.version) {
        const versionMatch = headerContent.match(patterns.version);
        if (versionMatch) {
          result.slicerVersion = versionMatch[1];
        }
      }
      break;
    }
  }
  
  // Use detected slicer patterns or try all patterns
  const patternsToTry = detectedSlicer 
    ? [SLICER_PATTERNS[detectedSlicer]] 
    : Object.values(SLICER_PATTERNS);
  
  for (const patterns of patternsToTry) {
    // Filament used (grams)
    if (!result.filamentUsedGrams && patterns.filamentUsedGrams) {
      const match = headerContent.match(patterns.filamentUsedGrams);
      if (match) {
        result.filamentUsedGrams = parseFloat(match[1]);
      }
    }
    
    // Filament used (meters/mm)
    if (!result.filamentUsedMeters && patterns.filamentUsedMeters) {
      const match = headerContent.match(patterns.filamentUsedMeters);
      if (match) {
        let value = parseFloat(match[1]);
        // Convert mm to meters if needed
        if (value > 1000) {
          value = value / 1000;
        }
        result.filamentUsedMeters = value;
      }
    }
    
    // Estimated time
    if (!result.estimatedTimeMinutes && patterns.estimatedTime) {
      const match = headerContent.match(patterns.estimatedTime);
      if (match) {
        result.estimatedTimeMinutes = parseTimeToMinutes(match[1]);
      }
    }
    
    // Layer height
    if (!result.layerHeight && patterns.layerHeight) {
      const match = headerContent.match(patterns.layerHeight);
      if (match) {
        result.layerHeight = parseFloat(match[1]);
      }
    }
    
    // Bed temperature
    if (!result.bedTemp && patterns.bedTemp) {
      const match = headerContent.match(patterns.bedTemp);
      if (match) {
        result.bedTemp = parseInt(match[1]);
      }
    }
    
    // Hotend temperature
    if (!result.hotendTemp && patterns.hotendTemp) {
      const match = headerContent.match(patterns.hotendTemp);
      if (match) {
        result.hotendTemp = parseInt(match[1]);
      }
    }
    
    // Filament type
    if (!result.filamentType && patterns.filamentType) {
      const match = headerContent.match(patterns.filamentType);
      if (match) {
        result.filamentType = match[1].trim();
      }
    }
    
    // Object name
    if (!result.objectName && patterns.objectName) {
      const match = headerContent.match(patterns.objectName);
      if (match) {
        result.objectName = match[1].trim();
      }
    }
  }
  
  // Try to get print name from filename or object name
  if (!result.printName) {
    if (result.objectName) {
      result.printName = result.objectName;
    } else if (filename) {
      // Remove extension and clean up
      result.printName = filename
        .replace(/\.(gcode|gco|g)$/i, '')
        .replace(/_/g, ' ')
        .replace(/-/g, ' ');
    }
  }
  
  // Extract thumbnail
  const thumbnail = extractThumbnail(content);
  if (thumbnail.data) {
    result.thumbnail = thumbnail.data;
    result.thumbnailFormat = thumbnail.format;
  }
  
  // Try generic patterns if slicer-specific didn't work
  if (!result.filamentUsedGrams) {
    // Generic pattern for filament weight
    const genericWeight = headerContent.match(/;\s*(?:filament|material)\s*(?:used|weight)\s*[:\s=]\s*([\d.]+)\s*g/i);
    if (genericWeight) {
      result.filamentUsedGrams = parseFloat(genericWeight[1]);
    }
  }
  
  if (!result.estimatedTimeMinutes) {
    // Look for TIME comment (common in Cura)
    const timeComment = headerContent.match(/;\s*TIME\s*:\s*(\d+)/i);
    if (timeComment) {
      result.estimatedTimeMinutes = Math.round(parseInt(timeComment[1]) / 60);
    }
  }
  
  return result;
}

/**
 * Convert grams to meters based on filament properties
 * Default: 1.75mm PLA at 1.24 g/cm³
 */
export function gramsToMeters(
  grams: number, 
  diameter: number = 1.75, 
  density: number = 1.24
): number {
  // Volume in cm³
  const volumeCm3 = grams / density;
  
  // Cross-sectional area in cm²
  const radiusCm = (diameter / 10) / 2; // Convert mm to cm
  const areaCm2 = Math.PI * radiusCm * radiusCm;
  
  // Length in cm, then convert to meters
  const lengthCm = volumeCm3 / areaCm2;
  return lengthCm / 100;
}

/**
 * Convert meters to grams based on filament properties
 */
export function metersToGrams(
  meters: number,
  diameter: number = 1.75,
  density: number = 1.24
): number {
  // Cross-sectional area in cm²
  const radiusCm = (diameter / 10) / 2;
  const areaCm2 = Math.PI * radiusCm * radiusCm;
  
  // Volume in cm³
  const lengthCm = meters * 100;
  const volumeCm3 = areaCm2 * lengthCm;
  
  // Weight in grams
  return volumeCm3 * density;
}
